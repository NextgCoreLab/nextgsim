//! RLS transport layer for RRC and user plane data
//!
//! This module provides the transport functionality for sending and receiving
//! RRC messages and user plane data over the RLS protocol.

use std::collections::HashMap;
use std::time::{Duration, Instant};

use bytes::Bytes;

use crate::protocol::{
    PduInfo, PduType, RlfCause, RlsMessage, RlsPduTransmission, RlsPduTransmissionAck,
};

/// Maximum number of PDUs that can be pending acknowledgment
pub const MAX_PDU_COUNT: usize = 128;

/// Maximum time to wait for PDU acknowledgment (in milliseconds)
pub const MAX_PDU_TTL_MS: u64 = 3000;

/// RRC channel types for RLS transport
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(u32)]
pub enum RrcChannel {
    /// BCCH-BCH (Broadcast Control Channel - BCH)
    BcchBch = 0,
    /// BCCH-DL-SCH (Broadcast Control Channel - DL-SCH)
    BcchDlSch = 1,
    /// DL-CCCH (Downlink Common Control Channel)
    DlCcch = 2,
    /// DL-DCCH (Downlink Dedicated Control Channel)
    DlDcch = 3,
    /// PCCH (Paging Control Channel)
    Pcch = 4,
    /// UL-CCCH (Uplink Common Control Channel)
    UlCcch = 5,
    /// UL-CCCH1 (Uplink Common Control Channel 1)
    UlCcch1 = 6,
    /// UL-DCCH (Uplink Dedicated Control Channel)
    UlDcch = 7,
}

impl RrcChannel {
    /// Creates an RrcChannel from a u32 value
    pub fn from_u32(value: u32) -> Option<Self> {
        match value {
            0 => Some(Self::BcchBch),
            1 => Some(Self::BcchDlSch),
            2 => Some(Self::DlCcch),
            3 => Some(Self::DlDcch),
            4 => Some(Self::Pcch),
            5 => Some(Self::UlCcch),
            6 => Some(Self::UlCcch1),
            7 => Some(Self::UlDcch),
            _ => None,
        }
    }

    /// Returns true if this is a downlink channel
    pub fn is_downlink(&self) -> bool {
        matches!(
            self,
            Self::BcchBch | Self::BcchDlSch | Self::DlCcch | Self::DlDcch | Self::Pcch
        )
    }

    /// Returns true if this is an uplink channel
    pub fn is_uplink(&self) -> bool {
        matches!(self, Self::UlCcch | Self::UlCcch1 | Self::UlDcch)
    }
}

/// Events generated by the RLS transport layer
#[derive(Debug, Clone)]
pub enum TransportEvent {
    /// Received RRC message
    RrcReceived {
        /// Cell/UE identifier
        endpoint_id: u32,
        /// RRC channel
        channel: RrcChannel,
        /// RRC message data
        data: Bytes,
    },
    /// Received user plane data
    DataReceived {
        /// PDU Session Identifier
        psi: u32,
        /// User plane data
        data: Bytes,
    },
    /// PDU transmission failed (no acknowledgment received)
    TransmissionFailure {
        /// List of failed PDU infos
        pdus: Vec<PduInfo>,
    },
    /// Radio link failure
    RadioLinkFailure {
        /// Cause of the failure
        cause: RlfCause,
    },
}

/// Pending PDU information for acknowledgment tracking
#[derive(Debug, Clone)]
struct PendingPdu {
    /// PDU info
    info: PduInfo,
    /// Time when the PDU was sent
    sent_time: Instant,
}

/// RLS transport manager
///
/// Manages the sending and receiving of RRC messages and user plane data
/// over the RLS protocol, including acknowledgment tracking.
#[derive(Debug)]
pub struct RlsTransport {
    /// STI (Simulated Transmission Identifier)
    sti: u64,
    /// Pending PDUs awaiting acknowledgment (indexed by PDU ID)
    pending_pdus: HashMap<u32, PendingPdu>,
    /// Pending acknowledgments to send (indexed by endpoint ID)
    pending_acks: HashMap<u32, Vec<u32>>,
    /// Next PDU ID to use
    next_pdu_id: u32,
    /// Maximum PDU TTL
    max_pdu_ttl: Duration,
    /// Current serving cell/UE (for data transmission)
    serving_endpoint: Option<u32>,
}

impl RlsTransport {
    /// Creates a new RLS transport manager
    pub fn new(sti: u64) -> Self {
        Self {
            sti,
            pending_pdus: HashMap::new(),
            pending_acks: HashMap::new(),
            next_pdu_id: 1,
            max_pdu_ttl: Duration::from_millis(MAX_PDU_TTL_MS),
            serving_endpoint: None,
        }
    }

    /// Sets the serving endpoint (cell for UE, or UE for gNB)
    pub fn set_serving_endpoint(&mut self, endpoint_id: u32) {
        self.serving_endpoint = Some(endpoint_id);
    }

    /// Clears the serving endpoint
    pub fn clear_serving_endpoint(&mut self) {
        self.serving_endpoint = None;
    }

    /// Gets the serving endpoint
    pub fn serving_endpoint(&self) -> Option<u32> {
        self.serving_endpoint
    }

    /// Sets the maximum PDU TTL
    pub fn set_max_pdu_ttl(&mut self, ttl: Duration) {
        self.max_pdu_ttl = ttl;
    }

    /// Creates an RRC PDU transmission message
    ///
    /// If `require_ack` is true, the PDU will be tracked for acknowledgment.
    pub fn create_rrc_transmission(
        &mut self,
        endpoint_id: u32,
        channel: RrcChannel,
        data: Bytes,
        require_ack: bool,
    ) -> Result<RlsPduTransmission, RlfCause> {
        let pdu_id = if require_ack {
            self.allocate_pdu_id(endpoint_id, channel, data.clone())?
        } else {
            0
        };

        Ok(RlsPduTransmission {
            sti: self.sti,
            pdu_type: PduType::Rrc,
            pdu_id,
            payload: channel as u32,
            pdu: data,
        })
    }

    /// Creates a user plane data transmission message
    ///
    /// User plane data is sent without acknowledgment tracking.
    pub fn create_data_transmission(&self, psi: u32, data: Bytes) -> RlsPduTransmission {
        RlsPduTransmission {
            sti: self.sti,
            pdu_type: PduType::Data,
            pdu_id: 0,
            payload: psi,
            pdu: data,
        }
    }

    /// Allocates a PDU ID and tracks the PDU for acknowledgment
    fn allocate_pdu_id(
        &mut self,
        endpoint_id: u32,
        channel: RrcChannel,
        data: Bytes,
    ) -> Result<u32, RlfCause> {
        // Check if we have too many pending PDUs
        if self.pending_pdus.len() >= MAX_PDU_COUNT {
            self.pending_pdus.clear();
            return Err(RlfCause::PduIdFull);
        }

        let pdu_id = self.next_pdu_id;
        self.next_pdu_id = self.next_pdu_id.wrapping_add(1);
        if self.next_pdu_id == 0 {
            self.next_pdu_id = 1;
        }

        // Check for duplicate PDU ID (shouldn't happen with wrapping)
        if self.pending_pdus.contains_key(&pdu_id) {
            self.pending_pdus.clear();
            return Err(RlfCause::PduIdExists);
        }

        let info = PduInfo {
            id: pdu_id,
            pdu: data,
            rrc_channel: channel as u32,
            sent_time: 0, // Will be set by caller if needed
            endpoint_id: endpoint_id as i32,
        };

        self.pending_pdus.insert(
            pdu_id,
            PendingPdu {
                info,
                sent_time: Instant::now(),
            },
        );

        Ok(pdu_id)
    }

    /// Processes a received PDU transmission message
    ///
    /// Returns any events generated by this message.
    pub fn process_pdu_transmission(
        &mut self,
        endpoint_id: u32,
        msg: &RlsPduTransmission,
    ) -> Vec<TransportEvent> {
        let mut events = Vec::new();

        // Queue acknowledgment if PDU ID is non-zero
        if msg.pdu_id != 0 {
            self.pending_acks
                .entry(endpoint_id)
                .or_default()
                .push(msg.pdu_id);
        }

        match msg.pdu_type {
            PduType::Rrc => {
                if let Some(channel) = RrcChannel::from_u32(msg.payload) {
                    events.push(TransportEvent::RrcReceived {
                        endpoint_id,
                        channel,
                        data: msg.pdu.clone(),
                    });
                }
            }
            PduType::Data => {
                // Only accept data from serving endpoint
                if self.serving_endpoint == Some(endpoint_id) {
                    events.push(TransportEvent::DataReceived {
                        psi: msg.payload,
                        data: msg.pdu.clone(),
                    });
                }
            }
            PduType::Reserved => {
                // Ignore reserved PDU type
            }
        }

        events
    }

    /// Processes a PDU transmission acknowledgment
    pub fn process_pdu_ack(&mut self, msg: &RlsPduTransmissionAck) {
        for pdu_id in &msg.pdu_ids {
            self.pending_pdus.remove(pdu_id);
        }
    }

    /// Creates acknowledgment messages for pending PDUs
    ///
    /// Returns a list of (endpoint_id, ack message) pairs.
    pub fn create_pending_acks(&mut self) -> Vec<(u32, RlsPduTransmissionAck)> {
        let pending = std::mem::take(&mut self.pending_acks);

        pending
            .into_iter()
            .filter(|(_, ids)| !ids.is_empty())
            .map(|(endpoint_id, pdu_ids)| {
                (
                    endpoint_id,
                    RlsPduTransmissionAck::with_pdu_ids(self.sti, pdu_ids),
                )
            })
            .collect()
    }

    /// Checks for expired PDUs and returns transmission failure events
    pub fn check_expired_pdus(&mut self) -> Vec<TransportEvent> {
        let mut events = Vec::new();
        let mut expired_ids = Vec::new();
        let mut expired_pdus = Vec::new();

        for (pdu_id, pending) in &self.pending_pdus {
            if pending.sent_time.elapsed() > self.max_pdu_ttl {
                expired_ids.push(*pdu_id);
                expired_pdus.push(pending.info.clone());
            }
        }

        for id in expired_ids {
            self.pending_pdus.remove(&id);
        }

        if !expired_pdus.is_empty() {
            events.push(TransportEvent::TransmissionFailure { pdus: expired_pdus });
        }

        events
    }

    /// Returns the number of pending PDUs
    pub fn pending_pdu_count(&self) -> usize {
        self.pending_pdus.len()
    }

    /// Processes an RLS message and returns any events
    pub fn process_message(
        &mut self,
        endpoint_id: u32,
        msg: &RlsMessage,
    ) -> Vec<TransportEvent> {
        match msg {
            RlsMessage::PduTransmission(pdu) => self.process_pdu_transmission(endpoint_id, pdu),
            RlsMessage::PduTransmissionAck(ack) => {
                self.process_pdu_ack(ack);
                Vec::new()
            }
            _ => Vec::new(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_rrc_channel_from_u32() {
        assert_eq!(RrcChannel::from_u32(0), Some(RrcChannel::BcchBch));
        assert_eq!(RrcChannel::from_u32(7), Some(RrcChannel::UlDcch));
        assert_eq!(RrcChannel::from_u32(8), None);
    }

    #[test]
    fn test_rrc_channel_direction() {
        assert!(RrcChannel::DlDcch.is_downlink());
        assert!(!RrcChannel::DlDcch.is_uplink());
        assert!(RrcChannel::UlDcch.is_uplink());
        assert!(!RrcChannel::UlDcch.is_downlink());
    }

    #[test]
    fn test_create_rrc_transmission() {
        let mut transport = RlsTransport::new(12345);

        let msg = transport
            .create_rrc_transmission(1, RrcChannel::UlDcch, Bytes::from_static(b"test"), true)
            .unwrap();

        assert_eq!(msg.sti, 12345);
        assert_eq!(msg.pdu_type, PduType::Rrc);
        assert_eq!(msg.payload, RrcChannel::UlDcch as u32);
        assert_ne!(msg.pdu_id, 0);
        assert_eq!(transport.pending_pdu_count(), 1);
    }

    #[test]
    fn test_create_data_transmission() {
        let transport = RlsTransport::new(12345);

        let msg = transport.create_data_transmission(5, Bytes::from_static(b"data"));

        assert_eq!(msg.sti, 12345);
        assert_eq!(msg.pdu_type, PduType::Data);
        assert_eq!(msg.payload, 5);
        assert_eq!(msg.pdu_id, 0);
    }

    #[test]
    fn test_process_pdu_transmission_rrc() {
        let mut transport = RlsTransport::new(12345);

        let pdu = RlsPduTransmission {
            sti: 67890,
            pdu_type: PduType::Rrc,
            pdu_id: 1,
            payload: RrcChannel::DlDcch as u32,
            pdu: Bytes::from_static(b"rrc message"),
        };

        let events = transport.process_pdu_transmission(1, &pdu);

        assert_eq!(events.len(), 1);
        assert!(matches!(
            &events[0],
            TransportEvent::RrcReceived {
                endpoint_id: 1,
                channel: RrcChannel::DlDcch,
                ..
            }
        ));
    }

    #[test]
    fn test_process_pdu_transmission_data() {
        let mut transport = RlsTransport::new(12345);
        transport.set_serving_endpoint(1);

        let pdu = RlsPduTransmission {
            sti: 67890,
            pdu_type: PduType::Data,
            pdu_id: 0,
            payload: 5,
            pdu: Bytes::from_static(b"user data"),
        };

        let events = transport.process_pdu_transmission(1, &pdu);

        assert_eq!(events.len(), 1);
        assert!(matches!(
            &events[0],
            TransportEvent::DataReceived { psi: 5, .. }
        ));
    }

    #[test]
    fn test_process_pdu_transmission_data_wrong_endpoint() {
        let mut transport = RlsTransport::new(12345);
        transport.set_serving_endpoint(1);

        let pdu = RlsPduTransmission {
            sti: 67890,
            pdu_type: PduType::Data,
            pdu_id: 0,
            payload: 5,
            pdu: Bytes::from_static(b"user data"),
        };

        // Data from non-serving endpoint should be ignored
        let events = transport.process_pdu_transmission(2, &pdu);
        assert!(events.is_empty());
    }

    #[test]
    fn test_pdu_acknowledgment() {
        let mut transport = RlsTransport::new(12345);

        // Create a transmission that requires ack
        let msg = transport
            .create_rrc_transmission(1, RrcChannel::UlDcch, Bytes::from_static(b"test"), true)
            .unwrap();
        let pdu_id = msg.pdu_id;

        assert_eq!(transport.pending_pdu_count(), 1);

        // Process acknowledgment
        let ack = RlsPduTransmissionAck::with_pdu_ids(67890, vec![pdu_id]);
        transport.process_pdu_ack(&ack);

        assert_eq!(transport.pending_pdu_count(), 0);
    }

    #[test]
    fn test_create_pending_acks() {
        let mut transport = RlsTransport::new(12345);

        // Simulate receiving PDUs that need acknowledgment
        let pdu1 = RlsPduTransmission {
            sti: 67890,
            pdu_type: PduType::Rrc,
            pdu_id: 1,
            payload: 0,
            pdu: Bytes::new(),
        };
        let pdu2 = RlsPduTransmission {
            sti: 67890,
            pdu_type: PduType::Rrc,
            pdu_id: 2,
            payload: 0,
            pdu: Bytes::new(),
        };

        transport.process_pdu_transmission(1, &pdu1);
        transport.process_pdu_transmission(1, &pdu2);

        let acks = transport.create_pending_acks();

        assert_eq!(acks.len(), 1);
        assert_eq!(acks[0].0, 1);
        assert_eq!(acks[0].1.pdu_ids, vec![1, 2]);
    }

    #[test]
    fn test_pdu_id_full() {
        let mut transport = RlsTransport::new(12345);

        // Fill up pending PDUs
        for i in 0..MAX_PDU_COUNT {
            transport
                .create_rrc_transmission(
                    1,
                    RrcChannel::UlDcch,
                    Bytes::from(vec![i as u8]),
                    true,
                )
                .unwrap();
        }

        // Next allocation should fail
        let result = transport.create_rrc_transmission(
            1,
            RrcChannel::UlDcch,
            Bytes::from_static(b"overflow"),
            true,
        );

        assert!(matches!(result, Err(RlfCause::PduIdFull)));
    }
}
