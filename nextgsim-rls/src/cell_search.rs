//! Cell search functionality for RLS protocol
//!
//! This module implements the cell search mechanism used by UE to discover
//! and maintain connections with gNB cells. Cell search is performed via
//! heartbeat messages sent to all addresses in the search space.

use std::collections::HashMap;
use std::net::SocketAddr;
use std::time::{Duration, Instant};

use crate::protocol::{RlsHeartbeat, RlsHeartbeatAck, Vector3};

/// Default heartbeat interval in milliseconds
pub const DEFAULT_HEARTBEAT_INTERVAL_MS: u64 = 1000;

/// Default heartbeat threshold for considering a cell lost (in milliseconds)
pub const DEFAULT_HEARTBEAT_THRESHOLD_MS: u64 = 2000;

/// Minimum allowed signal strength in dBm
pub const MIN_ALLOWED_DBM: i32 = -120;

/// Information about a discovered cell
#[derive(Debug, Clone)]
pub struct CellInfo {
    /// Unique cell identifier (local to this UE)
    pub cell_id: u32,
    /// STI (Simulated Transmission Identifier) of the cell
    pub sti: u64,
    /// Network address of the cell
    pub address: SocketAddr,
    /// Last time a heartbeat acknowledgment was received
    pub last_seen: Instant,
    /// Signal strength in dBm
    pub dbm: i32,
}

impl CellInfo {
    /// Creates a new `CellInfo`
    pub fn new(cell_id: u32, sti: u64, address: SocketAddr, dbm: i32) -> Self {
        Self {
            cell_id,
            sti,
            address,
            last_seen: Instant::now(),
            dbm,
        }
    }

    /// Updates the cell info with new heartbeat acknowledgment data
    pub fn update(&mut self, address: SocketAddr, dbm: i32) {
        self.address = address;
        self.last_seen = Instant::now();
        self.dbm = dbm;
    }

    /// Returns true if the cell is considered lost (no heartbeat for threshold duration)
    pub fn is_lost(&self, threshold: Duration) -> bool {
        self.last_seen.elapsed() > threshold
    }
}

/// Events generated by the cell search process
#[derive(Debug, Clone)]
pub enum CellSearchEvent {
    /// A new cell was discovered
    CellDiscovered {
        /// Cell identifier
        cell_id: u32,
        /// Cell STI
        sti: u64,
        /// Signal strength in dBm
        dbm: i32,
    },
    /// Signal strength changed for a cell
    SignalChanged {
        /// Cell identifier
        cell_id: u32,
        /// Old signal strength in dBm
        old_dbm: i32,
        /// New signal strength in dBm
        new_dbm: i32,
    },
    /// A cell was lost (no heartbeat response)
    CellLost {
        /// Cell identifier
        cell_id: u32,
    },
}

/// Cell search state manager for UE
///
/// Manages the discovery and tracking of gNB cells via heartbeat messages.
#[derive(Debug)]
pub struct UeCellSearch {
    /// UE's STI (Simulated Transmission Identifier)
    sti: u64,
    /// UE's simulated position
    sim_pos: Vector3,
    /// Search space (addresses to send heartbeats to)
    search_space: Vec<SocketAddr>,
    /// Discovered cells indexed by STI
    cells: HashMap<u64, CellInfo>,
    /// Mapping from `cell_id` to STI
    cell_id_to_sti: HashMap<u32, u64>,
    /// Counter for generating cell IDs
    next_cell_id: u32,
    /// Heartbeat threshold duration
    heartbeat_threshold: Duration,
    /// Last heartbeat cycle time
    last_heartbeat: Option<Instant>,
    /// Heartbeat interval
    heartbeat_interval: Duration,
}

impl UeCellSearch {
    /// Creates a new UE cell search manager
    pub fn new(sti: u64, search_space: Vec<SocketAddr>) -> Self {
        Self {
            sti,
            sim_pos: Vector3::default(),
            search_space,
            cells: HashMap::new(),
            cell_id_to_sti: HashMap::new(),
            next_cell_id: 0,
            heartbeat_threshold: Duration::from_millis(DEFAULT_HEARTBEAT_THRESHOLD_MS),
            last_heartbeat: None,
            heartbeat_interval: Duration::from_millis(DEFAULT_HEARTBEAT_INTERVAL_MS),
        }
    }

    /// Sets the UE's simulated position
    pub fn set_position(&mut self, pos: Vector3) {
        self.sim_pos = pos;
    }

    /// Sets the heartbeat threshold duration
    pub fn set_heartbeat_threshold(&mut self, threshold: Duration) {
        self.heartbeat_threshold = threshold;
    }

    /// Sets the heartbeat interval
    pub fn set_heartbeat_interval(&mut self, interval: Duration) {
        self.heartbeat_interval = interval;
    }

    /// Returns true if it's time to send heartbeats
    pub fn should_send_heartbeats(&self) -> bool {
        match self.last_heartbeat {
            Some(last) => last.elapsed() >= self.heartbeat_interval,
            None => true,
        }
    }

    /// Creates heartbeat messages to send to all addresses in the search space
    ///
    /// Returns a list of (address, heartbeat message) pairs
    pub fn create_heartbeats(&mut self) -> Vec<(SocketAddr, RlsHeartbeat)> {
        self.last_heartbeat = Some(Instant::now());

        self.search_space
            .iter()
            .map(|addr| (*addr, RlsHeartbeat::with_position(self.sti, self.sim_pos)))
            .collect()
    }

    /// Processes a heartbeat acknowledgment from a cell
    ///
    /// Returns any events generated by this acknowledgment
    pub fn process_heartbeat_ack(
        &mut self,
        sti: u64,
        address: SocketAddr,
        ack: &RlsHeartbeatAck,
    ) -> Vec<CellSearchEvent> {
        let mut events = Vec::new();

        if let Some(cell) = self.cells.get_mut(&sti) {
            // Existing cell - check for signal change
            let old_dbm = cell.dbm;
            cell.update(address, ack.dbm);

            if old_dbm != ack.dbm {
                events.push(CellSearchEvent::SignalChanged {
                    cell_id: cell.cell_id,
                    old_dbm,
                    new_dbm: ack.dbm,
                });
            }
        } else {
            // New cell discovered
            let cell_id = self.next_cell_id;
            self.next_cell_id += 1;

            let cell = CellInfo::new(cell_id, sti, address, ack.dbm);
            self.cells.insert(sti, cell);
            self.cell_id_to_sti.insert(cell_id, sti);

            events.push(CellSearchEvent::CellDiscovered {
                cell_id,
                sti,
                dbm: ack.dbm,
            });
        }

        events
    }

    /// Checks for lost cells and returns events for any that are lost
    pub fn check_lost_cells(&mut self) -> Vec<CellSearchEvent> {
        let mut events = Vec::new();
        let mut lost_stis = Vec::new();

        for (sti, cell) in &self.cells {
            if cell.is_lost(self.heartbeat_threshold) {
                lost_stis.push(*sti);
                events.push(CellSearchEvent::CellLost {
                    cell_id: cell.cell_id,
                });
            }
        }

        for sti in lost_stis {
            if let Some(cell) = self.cells.remove(&sti) {
                self.cell_id_to_sti.remove(&cell.cell_id);
            }
        }

        events
    }

    /// Gets cell info by cell ID
    pub fn get_cell(&self, cell_id: u32) -> Option<&CellInfo> {
        self.cell_id_to_sti
            .get(&cell_id)
            .and_then(|sti| self.cells.get(sti))
    }

    /// Gets cell info by STI
    pub fn get_cell_by_sti(&self, sti: u64) -> Option<&CellInfo> {
        self.cells.get(&sti)
    }

    /// Returns all discovered cells
    pub fn cells(&self) -> impl Iterator<Item = &CellInfo> {
        self.cells.values()
    }

    /// Returns the number of discovered cells
    pub fn cell_count(&self) -> usize {
        self.cells.len()
    }

    /// Returns the cell with the strongest signal
    pub fn best_cell(&self) -> Option<&CellInfo> {
        self.cells.values().max_by_key(|c| c.dbm)
    }
}

/// Cell tracking state manager for gNB
///
/// Manages UE discovery and tracking via heartbeat messages.
#[derive(Debug)]
pub struct GnbCellTracker {
    /// gNB's STI (Simulated Transmission Identifier)
    sti: u64,
    /// gNB's physical location for signal strength calculation
    phy_location: Vector3,
    /// Tracked UEs indexed by STI
    ues: HashMap<u64, UeInfo>,
    /// Mapping from `ue_id` to STI
    ue_id_to_sti: HashMap<u32, u64>,
    /// Counter for generating UE IDs
    next_ue_id: u32,
    /// Heartbeat threshold duration
    heartbeat_threshold: Duration,
}

/// Information about a tracked UE
#[derive(Debug, Clone)]
pub struct UeInfo {
    /// Unique UE identifier (local to this gNB)
    pub ue_id: u32,
    /// STI of the UE
    pub sti: u64,
    /// Network address of the UE
    pub address: SocketAddr,
    /// Last time a heartbeat was received
    pub last_seen: Instant,
}

impl UeInfo {
    /// Creates a new `UeInfo`
    pub fn new(ue_id: u32, sti: u64, address: SocketAddr) -> Self {
        Self {
            ue_id,
            sti,
            address,
            last_seen: Instant::now(),
        }
    }

    /// Updates the UE info with new heartbeat data
    pub fn update(&mut self, address: SocketAddr) {
        self.address = address;
        self.last_seen = Instant::now();
    }

    /// Returns true if the UE is considered lost
    pub fn is_lost(&self, threshold: Duration) -> bool {
        self.last_seen.elapsed() > threshold
    }
}

/// Events generated by the gNB cell tracker
#[derive(Debug, Clone)]
pub enum GnbTrackerEvent {
    /// A new UE was detected
    UeDetected {
        /// UE identifier
        ue_id: u32,
        /// UE STI
        sti: u64,
    },
    /// A UE was lost (no heartbeat received)
    UeLost {
        /// UE identifier
        ue_id: u32,
    },
}

impl GnbCellTracker {
    /// Creates a new gNB cell tracker
    pub fn new(sti: u64, phy_location: Vector3) -> Self {
        Self {
            sti,
            phy_location,
            ues: HashMap::new(),
            ue_id_to_sti: HashMap::new(),
            next_ue_id: 0,
            heartbeat_threshold: Duration::from_millis(DEFAULT_HEARTBEAT_THRESHOLD_MS),
        }
    }

    /// Sets the heartbeat threshold duration
    pub fn set_heartbeat_threshold(&mut self, threshold: Duration) {
        self.heartbeat_threshold = threshold;
    }

    /// Estimates signal strength based on distance
    pub fn estimate_dbm(&self, ue_pos: &Vector3) -> i32 {
        let dx = self.phy_location.x - ue_pos.x;
        let dy = self.phy_location.y - ue_pos.y;
        let dz = self.phy_location.z - ue_pos.z;

        let distance_sq = (dx as i64 * dx as i64 + dy as i64 * dy as i64 + dz as i64 * dz as i64) as f64;
        let distance = distance_sq.sqrt() as i32;

        if distance == 0 {
            -1 // 0 may be confusing
        } else {
            -distance
        }
    }

    /// Processes a heartbeat from a UE
    ///
    /// Returns the heartbeat acknowledgment to send and any events generated
    pub fn process_heartbeat(
        &mut self,
        sti: u64,
        address: SocketAddr,
        heartbeat: &RlsHeartbeat,
    ) -> (Option<RlsHeartbeatAck>, Vec<GnbTrackerEvent>) {
        let dbm = self.estimate_dbm(&heartbeat.sim_pos);

        // Ignore if signal is too weak
        if dbm < MIN_ALLOWED_DBM {
            return (None, Vec::new());
        }

        let mut events = Vec::new();

        if let Some(ue) = self.ues.get_mut(&sti) {
            // Existing UE
            ue.update(address);
        } else {
            // New UE detected
            let ue_id = self.next_ue_id;
            self.next_ue_id += 1;

            let ue = UeInfo::new(ue_id, sti, address);
            self.ues.insert(sti, ue);
            self.ue_id_to_sti.insert(ue_id, sti);

            events.push(GnbTrackerEvent::UeDetected { ue_id, sti });
        }

        let ack = RlsHeartbeatAck::with_dbm(self.sti, dbm);
        (Some(ack), events)
    }

    /// Checks for lost UEs and returns events for any that are lost
    pub fn check_lost_ues(&mut self) -> Vec<GnbTrackerEvent> {
        let mut events = Vec::new();
        let mut lost_stis = Vec::new();

        for (sti, ue) in &self.ues {
            if ue.is_lost(self.heartbeat_threshold) {
                lost_stis.push(*sti);
                events.push(GnbTrackerEvent::UeLost { ue_id: ue.ue_id });
            }
        }

        for sti in lost_stis {
            if let Some(ue) = self.ues.remove(&sti) {
                self.ue_id_to_sti.remove(&ue.ue_id);
            }
        }

        events
    }

    /// Gets UE info by UE ID
    pub fn get_ue(&self, ue_id: u32) -> Option<&UeInfo> {
        self.ue_id_to_sti
            .get(&ue_id)
            .and_then(|sti| self.ues.get(sti))
    }

    /// Gets UE info by STI
    pub fn get_ue_by_sti(&self, sti: u64) -> Option<&UeInfo> {
        self.ues.get(&sti)
    }

    /// Returns all tracked UEs
    pub fn ues(&self) -> impl Iterator<Item = &UeInfo> {
        self.ues.values()
    }

    /// Returns the number of tracked UEs
    pub fn ue_count(&self) -> usize {
        self.ues.len()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::net::{IpAddr, Ipv4Addr};

    fn test_addr(port: u16) -> SocketAddr {
        SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), port)
    }

    #[test]
    fn test_ue_cell_search_discovery() {
        let mut search = UeCellSearch::new(12345, vec![test_addr(4997)]);

        let ack = RlsHeartbeatAck::with_dbm(67890, -80);
        let events = search.process_heartbeat_ack(67890, test_addr(4997), &ack);

        assert_eq!(events.len(), 1);
        assert!(matches!(
            events[0],
            CellSearchEvent::CellDiscovered {
                cell_id: 0,
                sti: 67890,
                dbm: -80
            }
        ));
        assert_eq!(search.cell_count(), 1);
    }

    #[test]
    fn test_ue_cell_search_signal_change() {
        let mut search = UeCellSearch::new(12345, vec![test_addr(4997)]);

        // First heartbeat
        let ack1 = RlsHeartbeatAck::with_dbm(67890, -80);
        search.process_heartbeat_ack(67890, test_addr(4997), &ack1);

        // Second heartbeat with different signal
        let ack2 = RlsHeartbeatAck::with_dbm(67890, -70);
        let events = search.process_heartbeat_ack(67890, test_addr(4997), &ack2);

        assert_eq!(events.len(), 1);
        assert!(matches!(
            events[0],
            CellSearchEvent::SignalChanged {
                cell_id: 0,
                old_dbm: -80,
                new_dbm: -70
            }
        ));
    }

    #[test]
    fn test_gnb_tracker_detection() {
        let mut tracker = GnbCellTracker::new(67890, Vector3::new(0, 0, 0));

        let heartbeat = RlsHeartbeat::with_position(12345, Vector3::new(10, 0, 0));
        let (ack, events) = tracker.process_heartbeat(12345, test_addr(5000), &heartbeat);

        assert!(ack.is_some());
        assert_eq!(ack.unwrap().dbm, -10);
        assert_eq!(events.len(), 1);
        assert!(matches!(
            events[0],
            GnbTrackerEvent::UeDetected {
                ue_id: 0,
                sti: 12345
            }
        ));
        assert_eq!(tracker.ue_count(), 1);
    }

    #[test]
    fn test_gnb_tracker_weak_signal() {
        let mut tracker = GnbCellTracker::new(67890, Vector3::new(0, 0, 0));

        // UE very far away
        let heartbeat = RlsHeartbeat::with_position(12345, Vector3::new(1000, 0, 0));
        let (ack, events) = tracker.process_heartbeat(12345, test_addr(5000), &heartbeat);

        // Signal too weak, should be ignored
        assert!(ack.is_none());
        assert!(events.is_empty());
        assert_eq!(tracker.ue_count(), 0);
    }

    #[test]
    fn test_create_heartbeats() {
        let mut search = UeCellSearch::new(12345, vec![test_addr(4997), test_addr(4998)]);
        search.set_position(Vector3::new(100, 200, 0));

        let heartbeats = search.create_heartbeats();

        assert_eq!(heartbeats.len(), 2);
        assert_eq!(heartbeats[0].1.sti, 12345);
        assert_eq!(heartbeats[0].1.sim_pos.x, 100);
    }

    #[test]
    fn test_best_cell() {
        let mut search = UeCellSearch::new(12345, vec![]);

        // Add two cells with different signal strengths
        let ack1 = RlsHeartbeatAck::with_dbm(1, -80);
        search.process_heartbeat_ack(1, test_addr(4997), &ack1);

        let ack2 = RlsHeartbeatAck::with_dbm(2, -60);
        search.process_heartbeat_ack(2, test_addr(4998), &ack2);

        let best = search.best_cell().unwrap();
        assert_eq!(best.dbm, -60);
        assert_eq!(best.sti, 2);
    }
}
